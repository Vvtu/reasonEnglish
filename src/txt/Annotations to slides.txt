Текст к слайдам

1.  Титул:

Моя презентация называется "Reason:  рассказ о практическом применении".

На мой взгляд самое ценное это личные впечатления.
Пересказывать документацию по Ризон нет ни какого смысла. Легче все прочесть на сайте.
Будучи в отпуске, я решил переписать свой микро-проект на Ризон, для того, чтобы лучше изучить этот инструмент.
Я вел дневник, где постоянно записывал, то с чем сталкивался.
Опираясь на эти записи я готов сообщить вам квинтесенцию впечатлений.

Целью данного эксперимента повысить эффктивность работы фронтендера с помощью надежных и удобных инструментов.

Причины поиска новых иструментов это:  боль джаваскрипта и лень программиста.

Ну и конечно поиграться с настоящим функциональным языком.

Если у вас уже есть опыт работы с функциональными языками, Haskell, OCaml, Rust, Idris
то вы будете чувствовать себя достаточно комфортно с  Reason.
Если нет - то вынос мозга, получение индорфинов и прочих нейромедиаторов.

Наша цель также в том,
сможем ли мы (джаваскриптеры) сразу въехать в Reason и быть более эффетивными в работе с этим интсрументом?

Когда работаешь на настоящем языке, я бы сказал, языке будущего то не возникает вопросов типа,
  что будет если в setTimeout не передать второй аргумент?
  или
  не передать в setTimeout вообще никаких аргументов?

Все эти вопросы убираются сразу и однозначно.
Кстати, JS порождает много таких вопросов потому что он похож в некотором смысле на Ассеблер.
Дальше в работе мы будем использовать JS, как ассебмблер.


2. План


1. Сравнительная история языков и фреймворков

1969 - Появление языка Standard ML (Meta language) Эдинбургский университет Шотландия
вывод типов - алгоритм Хиндли-Милнера.

1990 - Haskell 1.0 University of Glasgow UK
1996 - OCaml was written at Institut national INRIA in France.

Haskell - функциональный, ленивый
OCaml - практичный, не ленивый ( в последствии получил синтаксис похожый на Haskell - с отступами )

Facebook - использует и Haskell и OCaml и даже Standard ML.
Haskell - используется для борьбы со спамом. Опыт признан удачным. Но мешает ленивость языка.
OCaml - используется для прототипирования. Первые версии Реакта написаны на SML и OCaml.
На OCaml написан pfff - static analysis, code visualizations, code navigations, or style-preserving source-to-source transformations such as refactorings on source code
Flow.

Я нарешался задач на Haskell 2 года назад. Использовал его как числодробилку. Влюбился в него.
Haskell - пользуется очень большим авторитетом у программистов, повлиял на многии языки

Будет интересно узнать, что думают настоящие хаскелисты о джаваскрипте.
Думают хорошо, с уважением.

Но указаывают на недостатки.

Главный  - late binding !

Почему-то не указали отсутвие immutable типов

Я веду к тому, что эти недостатки устранены в языке Ризон.
Мы можем писать понастоящему надежные программы.

Джордан разрабатывал Reason уже давно.
Reason разрабатывался как строго типизированный,
быстрый и упрощенный двойник JavaScript,
только без исторического хлама, но с доступом сразу к двум экосистемам: JS и OCaml!

В 2016 году Bloomberg сделал свой проект по созданию компилятора OCaml -> JS открытым.
Backlescript (пряжка, скобка),

Reason получил второе дыхание.
Соместными усилиями в Backlescript встроили поддержу языка Reason.

Refmt   как  Gofmt

В общем все показалось, что найден убийца JS.


Зачем мучится с изучением нового языка ?

  80% семантики OCaml (то есть, как он работает) уже прямо сопоставляется
  с современным JavaScript и наоборот*;
  если убрать некоторые нехорошие части JavaScript и добавить несколько приятных вещей,
  можно на самом деле получить то, что компилируется в довольно читаемый JS.

  Тем не менее, не совсем ясно, какие части JS убрать,
  чтобы вписать его в форму языка с хорошей семантикой и 100% типизацией.
  Но мы можем пойти в обратном направлении от уже солидного простого и быстрого языка,
  и немного донастроить его так, чтобы он выглядел как JS и был лучше, чем JS.


Большинство фронтендеров начинало изучать программирования с JS.
Тех, для кого JS является первым языком программирования, очень трудно
перевести на другой язык программирования, потому что JS это очень мощный
и гибкий язык. Недостатки JS появляются только при написании больших сложных программ.

Для тех кто пришел в JS с других языков и платформ (я в том числе) недостатки JS
(при написании больших программ) - огромны.



"The Whitespace Thing" is an alternative syntax for OCaml
that uses indentation to group multi-line expressions,
like Python and Haskell.
This is a controversial feature that some people will always love and some people will always hate.
Using pretty much the same indentation patterns you put in your code anyway, "The Whitespace Thing" eliminates:
          The ; operator for sequences of expressions
          Multi-line parenthesizations in nested function applications
          Ambiguity involving nested let, if-else, and try-with expressions, and associated parenthesization
          The parenthetical keywords in, done, end, and begin
          The heinous ;; toplevel statement operator

В Ризон вместо скоуп отделяется фигурными скобками, а не отступами.

  В кратце сравним язык OCaml, Haskell.
  Кто на кого повлиял.
  Красота синтаксиса , новый синтаксис Хаскел.
  Недостатки Javascript по версии хаскелистов.
  Позднее связывание - пример с тестом на BroadBar.Item
  Мутабельность - примеры с пул реквестами от Димы.
  Джаваскрипт - не функциональный язык. Множество сайд эффектов

2. Плюсы Reason
3. Минусы Reason
4. Сравнение ReasonML и JS на простых задачках
5. Как я переписал свой микро-проект с ReactJS на ReasonReact.


Описание кода на джаваскриптере:

Перемешивание карточек (любых элементов).

1. reshuffle1
Сначало мы делаем map, в котором навешиваем нашим карточкам
случайные числа.
Потом мы сортируем этот массив, в котором каждый элемент это
массив из двух элементов. Случайное число и карточка.
Затем мы делаем map, с помощью которого очищаем наши карточки
от навешеных случайных чисел.
Получаем перемещанный массив.

reshuffle2
2. Можем сделать код более красивым, скомбинировав все в одно выражение,
применяя очередную функцию к результату предыдущей.
Лаконичный код.
Проблема в том, он проходится отладчиком как одна строка.

Возможность применять функцию к аргументу, а не вставлять аргумент
в вызов функции считается очень большим достижением JS.

Считается, что для этого в том числе и нужен this.
Один програмист менеджер с большим стажем работы в Яндексе,
говорил, что когда проводит собеседования при приеме на работу в
яндекс, очень много уделяет времени вопросам про this.
Видимо, влюбился в this и считает это огромным достижением
Скорее всего не знает, как такие вещи пишутся на функциональных языках.


reshuffle3
3. Есть еще вариант написания перемешивания reshuffle3
Может быть он быстрее, но он более чувствительный к качеству
функции Math.random().
В строке где используется slice делается копия массива,
чтобы вернуть перемешанную копию и не испортить исходный массив.

reshuffle4
4.reshuffle3 нарвется на проблему разрещенных массивов.

Чтобы не сортировать элементы, которых нет, можно вместе
slice использовать filter.

Теперь оставим этот код reshuffle2 на экране, и будем сравнивать его
с кодом на Reason.














You can do this with Ramda's transducers.

(Disclaimer: I'm a Ramda author)

While a normal composition of regular Ramda functions will loop for every list transformation,
a transduced one will run each function in the composition on each iteration.
Note that for technical reasons,
the composition runs in the reverse order when using transducers.
Not every function is a transducer.
The documentation uses this note to indicate one:
 "Acts as a transducer if a transformer is given in list position."
  This is included in both map and filter.
  There are several functions that make it easier to work with transducers.
  into is one of them.

Still, it might be easier to write your own filterMap function.
 Is isn't hard: