Текст к слайдам

Если у вас уже есть опыт работы с функциональными языками, Haskell, OCaml, Rust, Idris
то вы будете чувствовать себя достаточно комфортно с  Reason.


  Позднее связывание - пример с тестом на BroadBar.Item



"The Whitespace Thing" is an alternative syntax for OCaml
that uses indentation to group multi-line expressions,
like Python and Haskell.
This is a controversial feature that some people will always love
and some people will always hate.
Using pretty much the same indentation patterns you put in your code anyway,
"The Whitespace Thing" eliminates:
          The ; operator for sequences of expressions
          Multi-line parenthesizations in nested function applications
          Ambiguity involving nested let, if-else, and try-with expressions, and associated parenthesization
          The parenthetical keywords in, done, end, and begin
          The heinous ;; toplevel statement operator


ПАМЯТКА

1.  Let Binding

В Re есть let, который означает тоже, что и const в JS

let, var -  нет, все иммутабельно!
И это замечательно.
Инструмент, которым вы пользуетесь не должен быть слишком гибкий и мощный.
Иммутабельность нивелирует целый класс ошибок от сайдэфектов.
Борюсь на работе на код ревью с сайд эффектами.
В Reason - ничего нельзя смутировать.

Есть рефы. Которые мутабельны, но они мне не нужны.
Это дань ООП от OCaml.
Но, возможно они нужны для написания каких-то сугубо мутабельных вещей.
Где нужно сделать сайд-эффект.


2. String & Char

Строки такие же как в JS, но кавычки строго двойные.
Одинарные кавычки для типа char  -  int  0..255
Для конкатенации используем двойной плюс.
И это очень хорошо для выведения типов! Проверено временем.

Есть синтаксис для строк с UNICODE.  {js| ... |js}
Но форматтер ломает такие строки.
Он находит в них что-то, что старается изменить.


3. Boolean
как в JS
теперь компилируется в JS true false

Тройное равно - как в JS, по ссылке. Очень хорошо для React.

Двойное равно - работает совсем по другому.
Это структурное сравнение в глубину.
Советуют - не пользоваться.

А такого сравнения, чтобы было приведение типов друг к другу - нет.

4. Number

В Reason есть int   (это int32)

Для операций между целыми числами и числами с плавающей точкой
используются разные операторы
+  и +.   и т.д.

и это тоже хорошо.
Это облегчает выведение типов.
Дисскуссия о разных операторах для сложения - закрыта в OCaml
Все проверенно временем.

5. Object/Record

В этой таблицы сравниваются совершенно разные сущности.
Хотя выглядят они почти одинаково.

Рекорды это типизированные записи с именнованными полями,
которые компилируеются в JS массивы.
За счет этого они очень быстры.

Символ  "три точки" используюется в ограниченном по сравнению с JS варианте.
Его можно использовать только с левой части.

Тип рекорда нужно объявлять или "импортировать" из друго модуля.

Имена полей, существуют только в компайл тайме.
В скопилированом варианте они заменяются на индексы.
Поэтому все работает быстро и точно.

Я проводил собственные бенч-тесты на производительность.
JS массивы быстрее JS  объектов в среднем в 4 раза (зависит от движка)

6. Array
Для функциональности js-массивов в Reason есть:

Есть массивы   [|1,2,3|] (кстати они здесь мутабельные, но гомогенные )
  - мне они практически не нужны
  - практически, они нужны для мутабельности и интеропа с JS

Есть таплы, кортежи
  - очень удобны
  - иммутабельны
  - гетерогенны
  - комбинация switch (тапл)  - отличная вещь и устраняет целый класс ошибок

Есть списки
  - очень удобны
  - иммутабельны  (и это отлично)
  - гомогенны (и это отлично)
  - с очень быстрыми легкими операциями добавление головы и отделения головы
  - компилируются в массивы массивов
  - пустой список - очень легкая вещь - это константа 0
  (создавайте столько пустых списков, сколько хотите)
  - но деструкция на списках может запутать джаваскриптера

в общем таплы и списки (и рекоды) очень хорошие,
   где нужно гетерогенные данные - два варианта
      (таплы, если без церемоний и рекорды)
   - гомогенные данные - списки


Null,undefined
  - нету
  - есть опшионал ( тип данных Maybe - Haskell )
  - недавно поменялась компиляция опшионал (раньше в массив, теперь undefined)
  - опшионал очень удобен

Function
  - копии стрелочных функций из JS
  - отличие в каринге  a = f(x,y) - это тоже самое a = f(x)(y);
    и  let f = (x,y) =>     тоже самое что  и   let f = (x) => (y) =>
    и это очень хорошо (мы будем это постоянно использовать)

Остальное - не надо пока.
  Комментарии  - /* ...  */  не очень удобные.




///     JAVASCRIPT ///////////

Перемешивание карточек (любых элементов).

1. reshuffleJS1
Сначало мы делаем map, в котором навешиваем нашим карточкам
случайные числа.
Потом мы сортируем этот массив, в котором каждый элемент это
массив из двух элементов. Случайное число и карточка.
Затем мы делаем map, с помощью которого очищаем наши карточки
от навешеных случайных чисел.
Получаем перемещанный массив.

reshuffleJS2
2. Можем сделать код более красивым,
скомбинировав все в одно выражение (цепь),
применяя очередную функцию к результату предыдущей.
Лаконичный код.
Проблема в том, он проходится отладчиком как одна строка.

Хорошо бы если был бы плагин (vscode extesion), который
преобразовывал reshuffleJS2 в reshuffleJS1 и обратно, по нажатию
хот кея. Для отладки.


Возможность применять функцию к аргументу, а не вставлять аргумент
в вызов функции считается очень большим достижением JS.

Считается, что для этого в том числе и нужен this.
Один програмист менеджер с большим стажем работы в Яндексе,
говорил, что когда проводит собеседования при приеме на работу в
яндекс, очень много уделяет времени вопросам про this.
Видимо, влюбился в this и считает это огромным достижением
Скорее всего не знает, как такие вещи пишутся на функциональных языках.


reshuffleJS3
3. Есть еще вариант написания перемешивания reshuffle3
Может быть он быстрее, но он более чувствительный к качеству
функции Math.random().
В строке где используется slice делается копия массива,
чтобы вернуть перемешанную копию и не испортить исходный массив.

reshuffleJS4
4.reshuffle3 нарвется на проблему разрещенных массивов.

Чтобы не сортировать элементы, которых нет, можно вместе
slice использовать filter.

Теперь оставим этот код reshuffle2 на экране, и будем сравнивать его
с кодом на Reason.

------  REASON ---------------------

1. reshuffle0 -
Не пугайтесь, что код выглядит страшно.
Когда мы будем переходить к сделующим вариантам resuffle,
код будет становиться красивее. Дойдем до resuffle9 10 11

Алгоритм такой же, как в Javascript

Нет оператора return!
Последнее выражение всегда является
возвращаемым результатом работы функции.

Для карточек используем списки.
Это отличная вешь.
Здесь они точно такие же, как в Haskell, OCaml, и др ...
Гомогенны (однородными), иммутабельны !, легковесные
Для списков есть самые базовые операции:
1. Получить головной элемент списка, и его хвост
2. Создать новый список из головного элемента и списка,
который будет хвостом
3. Проверить, пуст ли список
 эти операции делаются за констатное время и очень быстры

Очень легковестным является создание пустого списка.
Пустой список это константа - это даже не пустой массив.
об этом сказано в документации Reason.
Создавайте столько пустых списков, сколько хотите. Это бесплатно.

Однако: получение длинны списка уже не быстрая операция.

Списки и массивы в Reason гомогенны (однородными).
Все колекции, для которых есть функция map - должны быть
Для тех, кто привык к
гетерогенным массивам джаваскрипта могу сказать следующее:
На это есть причины.
Намного лучше иметь дело с гомогенными колекциями.
Поначалу это кажется неудобным
Но такой подход невелирует целый класс тяжелых ошибок.
В документации Reason сказано на этот счет:

"Система типов не всемогуща и не должна быть таковой;
некоторые со вкусом подобранные компромиссы должны быть применены
для того, чтобы язык был простым, производительным (как компиляция, так и скорость работы)
и легким для понимания."

В общем - в данном докладе я буду углубляться в эту тему.

List - это название модуля, откуда берутся функции map и sort

Используем кортежи (таплы tuples)
В данном случае мы должны использовать кортежи, так как они
гетерогенны, быстры удобны.
Их рекомендуется использовать:


Списки и массивы в Reason гомогенны. Для тех, кто привык к
гетерогенным массивам джаваскрипта могу сказать следующее:
Намного лучше иметь дело с гомогенными колекциями.
ТАк сделано в Haskell в OCaml и все остальных выдающихся языках
Поначалу это кажется неудобным
НО такой подход невелирует целый класс тяжелых ошибок.
В документации про таплы тоже написано, где и как их лучше использовать.
Это как раз тот случай.
Для таплов, состоящих из двух элементов, определены функции
fst, snd. Но только для 2-tuples !!!
Но лучше извлекать значения из таплов патерн матчингом.
Или деструктивным присваиванием как в джаваскрипте.


reshuffle1
Заменили fst snd на паттерн матчинг.

reshuffle2-

открытие модуля

Постоянное обращение к значению / типу в модуле
может быть утомительным.
Мы можем открыть определение модуля и ссылаться на
его содержимое, не добавляя к нему имя.
Два способа: open и имя модуля перед скобкой.
open List;  - область видимости, как у переменных.


reshuffle3 -
Подставил значение p1 вместо p1
          значение p2 вместо p2
          значение p3 вместо p3

Абсолютно не читаемое сложное выражение.


reshuffle4 -
Наконец переходим к использованию функции
fast pipe -> для джаваскриптовых функций
(только для них скорее всего)
лучше обойтись без JS и даже без массивов JS
если мне понадобиться функциональность JS массивов,
то я лучше буду использовать Map с int ключом
для нормальных функциональных  |>

не перепутать!   -> и  |>

это удобный оператор,
который позволяет" перевернуть " код наизнанку.

|> точная копия application operator (Haskell),
который обозначается как $

reshuffle5 -
Можем создавать свои операторы потому, что операторы это
функции двух аргументов.

Более того, мы можем переопредить существующие операторы
например +
После этого мы не сможем использовать оператор +

Ramda -
"rationale" - библиотека, вдохновленная Рамдой.
Инфиксные опрераторы оттуда.

Мне показался полезным   |?: Optional Or
Аналог  JS   const a = b || c || 0;
Можно сделать свой -
например такой

let (|?) = (x, df) =>
  switch (x) {
  | Some(_) => x
  | none => df
  };
let otvet = None |? Some(0);
Js.log(otvet);


reshuffle7
Композиция двух функций.

в Haskell для композиции двух функция применяется точка
так назыаемый право-ассоциативный конвеер

f = f1 . f2 . f3
означает  f(x) ===  f1(f2(f3(x)))

Такой инфиксный опрератор я создать не смог, потому у него
правая ассоциативность. И не нашел в языке такого оператора, может он есть.
Надо копать OCaml.

Скорее всего можно задавать какой вид ассоцитивности нам нужен
ТОже не нашел.

Я решил создать лево-ассоциативный конвеер
let (==>) = (f1, f2, x) => f2(f1(x)); /* композиция функций */

Теперь можем переписать нашу функцию так, reshuffle7

reshuffle8 - убираем аргумент x

reshuffle9 - уже красиво (без аргумента x)

осталось сделать последний шаг

reshuffle10 -
убираем аргумент  dic

let reshuffle10 =
     map(x => (Random.int(1000000), x))
     ==> sort(((x, _), (y, _)) => x - y)
     ==> map(((_, x)) => x);

Такой код работатет в Repl и в  Playground
OCaml -то же работает в таком варианте,

Но не работает здесь в приложении

Получаем такую ошибку.
This expression's type contains type variables that can't be generalized:
     list('_a) => list('_a)

Видимо, немного упростили компилятор.
Сделали его более быстрым, за счет уменьшения количества проходов.

Компилятор Reason действительно быстрый.
Blazing fast - молниеносный !

reshuffle11c -
это OCaml вариант этой функции
очень похож,
Некоторые скобки ушли, некоторые появились

 Скобки вокруг всех трех выражений обязательны,
   так как нет скобок у аргументов.

Появилось fun для объявления функций
Вместо функций двух или более аргументов (там где sort) используется каскад


Хотел тут сказать, что на Haskell код этой функции был бы совсем красивым и лаконичным,
но вспомнил, что там, чтобы работать с random числами, нужно все дополнительно оборачивать в
монаду. Случайные числа - ломают понятие чистой функции. Каждый раз дают разный результат.
Работа со случайными числами в Haskell - то еще приключение.
Поэтому язык OCaml (то есть я хотел сказать Reason) более практичный, хотя имеет более неказистый синтаксис.




--------------

Посмотрим где применяется наша функция resuffle

ПРограмма сделана так, что при ее старте
в didMount бросается экшион Restart
Также этот экшион бросается если мы меняем настройки
программы (выбор словаря ...)

App.re  -  редьюсер - Restart case

ЛОгирование в консоль
Инициализация генератора случайных чисел

Дальше выбор словарей
Одним switch - выбираем сразу два словаря
Дальше формируем список allCards - это список всех карточек

Берем три случайные карточки из
старого словаря ...  (это отдельная задача)
Я хотел ее рассмотреть отдельно но нет времени
Поэтому она решается здесь просто
Перемешивается старый словарь и берется первые три карточки

и подсоедияем к этим трем карточкам перемешенный новый словарь


Используем reshuffle5 - хотя можно использовать
любой от 0 до 9  (см выпадашка при наведении курсора)

Используем две функции takeItems и dropItems

Почему-то в среди стандарного набора функций  List (наведение курсора)
нет take и drop ( может я плохо искал)
Для Haskell это самые базовые распространенные функции

Пришлось написать их самому

Для drop - хвостовая рекурсия
Можем просмотреть результат компиляции.

Видно, что если takeItems - это не совсем легкая и быстрая
(хотя она конечно легкая и быстрая на маленьких n,
но в ней будет создание нового списка)

ТО dropItems - это совсем легкая функция.
Не происходит никакого создания нового списка, никакого выделения
памяти.
Просто возращается метка на какой-то элемент списка.
И мы можем работать с этой меткой как с настоящим списком
Это и есть настоящий список, но он полностью совпадает с частью
исходного

Опять же видно, как удобно использовать switch

Все пришется в стейт
allCards - пишется в стейт два раза, второй как - remainingCards
но опять же - все по ссылке.
Это просто метка.
Когда мы будем двигаться по списку remainingCards,
отбрасывая его карточки по одной,
опять же это будет просто метка, указывающая на какую
то часть allCards



















You can do this with Ramda's transducers.

(Disclaimer: I'm a Ramda author)

While a normal composition of regular Ramda functions will loop for every list transformation,
a transduced one will run each function in the composition on each iteration.
Note that for technical reasons,
the composition runs in the reverse order when using transducers.
Not every function is a transducer.
The documentation uses this note to indicate one:
 "Acts as a transducer if a transformer is given in list position."
  This is included in both map and filter.
  There are several functions that make it easier to work with transducers.
  into is one of them.

Still, it might be easier to write your own filterMap function.
 Is isn't hard:





 ДОНАСТРОИТЬ