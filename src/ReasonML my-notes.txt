1. Build a local version of OCaml compiler touch: s.h: Permission denied - Пришлось делать даунгрейд версии npm 4.0.0. - иначе не проходила установка

2. Два варианта создания стартового проекта:

	--- BuckleScript's bsb build system has an init command that generates a project template. The react theme offers a lightweight solution optimized for low learning overhead and ease of integration into an existing project.
It compiles to straightforward JS files, so you can open index.html directly from the file system. No server needed.


	--- Reason Scripts (Aka Create-React-App) As with create-react-app, reason-scripts comes with a server and hot-reloading built in.



3. Need to switch to nam 4.0.0 again - to install ocamlmerlin

3. Увидел много   <div> (ReasonReact.string(...) </div>  - многословность ReasonReact.string(

5. Размер js бандла reason React - 126 кБ. (  cra - 118 кБ)

4. Странный способ комментировать - не удобный
   Странный let в отличии от  "let in" в OCaml
   Кавычки - двойные (странно)?  - конкатенация строк  ++ - тоже многословно.
   Equal - deep Equal ?
   Integers - 32  Careful when you bind to JavaScript numbers! Long ones might be truncated. Bind JS number as float instead.

  Отличаются символы арифметических операций для целых  и плавающих чисел. "Why the heck can't I just use an overloaded + for both int and float?"

5.  Mutable Update.    Record fields can optionally be mutable. This allows you to update those fields in-place with the = operator.


6. Lists vs Arrays - Array
	let myList = [1, 2, 3];
	( in js it  [1,[2,[3]]]  - если очень много маленьких элементов в списке, то будет большой оверхед, в этом случае нужно испльзовать чистый массив  )


	Arrays are like lists, except they are:
		mutable
		fast at random access & updates
		fix-sized on native (flexibly sized on JavaScript)
		You'd surround them with [| and |].

		let myArray = [|"hello", "world", "how are you"|];

		--  Списки - очень удобная вещь для
		let a = [1,2,3];
		let b = [0, ...a];

		Will memory for the list a be actually allocated, or will doSomething simply reuse the list b?

		In the worst case, both a and b will exist in memory in their entirety.
		Note that even then, the contents of the two lists will only exist once,
		shared between both lists, so we're only talking about the "spine" of the lists existing twice.

		In the best case, depending on how b is defined and what doSomething does,
		the compiler might do some hoopy magic
		to turn the whole thing into a tight constant-space loop
		that generates the contents of the list as it processes them,
		possibly involving no memory allocation at all. Maybe.

		But even in the very worst case, you're duplicating the spine of the lists.
		You'll never duplicate the actual elements in the list.


7.  Функции - как в стрелочные функции  в Js.
	- есть возможность именнованных аргументов.
	In OCaml/Reason, you can attach labels to an argument:
	let addCoordinates = (~x, ~y) => {
  	/* use x and y here */
	};

  - rec - для рекурсивных функций

	- аноноимные функции
	   /* anonymous function. Listed for completeness only */
				(x) => (y) => 1;
				/* sugar for the above */
				(x, y) => 1;
				/* assign to a name */
				let add = (x, y) => 1;

				With Type Annotation:   let add = (x: int, y: int): int => 1;



Standalone Type Signature

And In Interface Files

8. let rec qsort = a =>
  switch (a) {
  | [] => []
  | [x, ...y] => {
    let p1 = qsort(List.filter(e => e > x, y));
    let p2 = qsort(List.filter(e => e <= x, y));
    p1 @ [x, ...p2]
    }
  };

let c = qsort([5,10,1,3,6,8,2]);
Js.log(c);

List.filter( - не удобно
@ - не удобно

В общем - на половину Ocaml, на половину JavaScript
больше в сторону Ocaml

Может лучще полностью прогрммировать на Ocaml ?


9.  Если компилируется, то значит работает.  Это правда.

10. ReasonML records -  это массивы JS.
Массивы - в 2.5 раза быстрее чем объекты (мои измерения)
Значит - рекогдс быстрее чем объекты.  Стейт - это в основном рекордс.
Таким образом работа со стейтом - очень быстрая.

11. Почему не TypeScript ? Я думаю - иммутаельность !

12.
“Most people make the mistake of thinking design is what it looks like.
People think it’s this veneer – that the designers are handed this box and told,
‘Make it look good!’
That’s not what we think design is.
It’s not just what it looks like and feels like.
Design is how it works.” – Steve Jobs

This quote is from the 2003 New York Times article “The Guts of a New Machine.”


13. Когда работаеш с рекордами - компилятор плодит много доп переменных
type person = {
  age: string,
  name: string,
  birthDate: string,
};
let me = {
  age: "5" ++ " " ++ string_of_int(Random.int(100)),
  name: "Big Reason" ++ " " ++ string_of_int(Random.int(100)),
  birthDate: "11.03.1980" ++ " " ++ string_of_int(Random.int(100)),
};
let notMe = {...me, name: "VVtu XA " ++ string_of_int(Random.int(10))};
Js.log(notMe);
-----------------
var me_000 = /* age */"5 " + String(Random.$$int(100));
var me_001 = /* name */"Big Reason " + String(Random.$$int(100));
var me_002 = /* birthDate */"11.03.1980 " + String(Random.$$int(100));
var me = /* record */[
  me_000,
  me_001,
  me_002
];

Чтобы можно было легко создавать новые рекорды из  старых

var notMe_000 = me_000;
var notMe_001 = /* name */"VVtu XA " + String(Random.$$int(10));
var notMe_002 = me_002;
var notMe = /* record */[
  notMe_000,
  notMe_001,
  notMe_002
];

13. Отличный каринг на примере перетасовки любых сущностей
 let reshuffle = dic =>
    dic
    |> List.map(item => (item, Random.int(10000000)))
    |> List.sort(((_, i), (_, j)) => i - j)
    |> List.map(((item, _)) => item);

		но нужны лишние скобки в последнем List.map

- !!! ошибка с недостающими скобками в треьей заключительной строке.
вот что значит "срестили ужа с ежом"
 (x,_) => x - означает функцию от двух переменных,
 а нам нужно было функцию с деструкцией тапла в аргументе
 в итоге правильно ((x,_)) => x  - это функция от одного аргумента.
Но все это сразу становится видным из за отличного фантастического контроля типов.

14. В общем - гораздо меньше хлама.

15. Первым делом подключил css и сделал инклюды
[%bs.raw {|require('./App.css')|}];  -- css взял из своего старого проекта без изменений

include Reshuffle;
include Dictionaries;   --  Вместе инклюдами подтянул типы данных



16. Вторым делом написал тип state
type state = {
  activeIndex: int,
  showEnglish: bool,
  showAdvanced: bool,
  appcodeIsSpeaking: bool,
  randomDictionary: Dictionaries.pairList,
};

тоже очень удобно для исключения дальнейших ошибок

17. Дальше написал
	initialState: () => {
    activeIndex: 0,
    showEnglish: false,
    showAdvanced: false,
    appcodeIsSpeaking: false,
    randomDictionary: Reshuffle.reshuffle(Dictionaries.dictionary1),
  },

18. Пропсы - как именованные аргументы
	let make = (~message, _children) => { }

	In OCaml/Reason, you can attach labels to an argument:
		let addCoordinates = (~x, ~y) => {
  		/* use x and y here */
		};
------

19. Решение задачи с яндекс собеседования бека
Найти за один проход по односвязанному списку 3 элемент с конца списка.
-- хвостовая рекурсия
let rec get3rec = (a, zapas, n) =>
  switch (a) {
  | [] =>
    if (n === 0) {
      switch (zapas) {
      | [] => (-1)
      | [o, ..._] => o
      };
    } else {
      (-1);
    }
  | [_, ...y] =>
    if (n === 0) {
      switch (zapas) {
      | [] => (-1)
      | [_, ...rest] => get3rec(y, rest, 0)
      };
    } else {
      get3rec(y, zapas, n - 1);
    }
  };

let get3 = a => get3rec(a, a, 3);

let otvet = get3([0,0,1,2,3,4,5,6,7,8]);

Js.log(otvet);

-----
решение задачи о третьем элементе через левую и правую свертки
let otvet = [1, 2, 3, 4, 5, 6];

let rev = xxx => List.fold_left((a, x) => [x, ...a], [], xxx);
/*let fold_right: (('a, 'b) => 'b, list('a), 'b) => 'b; */

let get3_right_000 = xxx =>
  List.fold_right(
    ( x, (res, n)) =>
      if (n === 1) {
        (x, n - 1);
      } else {
        (res, n - 1);
      },
    xxx,
    ((-1), 3),
  );
let get3_right = xxx => {
  let (res0,_) = get3_right_000(xxx);
  res0;
};
Js.log(get3_right(otvet));

let get3_left_000 = xxx =>
  List.fold_left(
    ( (res, n), x ) =>
      if (n === 0) {
        let [_, ...newRes] = res;
        (newRes, 0);
      } else {
        (res, n - 1);
      },
        (xxx, 3),
    xxx,
  );
let get3_left = xxx => {
  let (res0,_) = get3_left_000(xxx);
  let [res00,..._] = res0;
  res00;
};
Js.log(get3_left(otvet));

-------


20.    Изменение порядока аргументов при переходе от left к right  не очевиден
         List.fold_left( func(akkum, value) => akkum, akkum , list)
         List.fold_right( func(value, akkum) => akkum,  list, akkum)

- у хаскеля при переходе от foldl к foldr меняется только порядок аргументов в функции func
foldl :: (b -> a -> b) -> b -> [a] -> b
foldr :: (a -> b -> b) -> b -> [a] -> b


21. Unit  type - like void, nil, null in other languages.
// ------------------------------------------------
ReasonML unit — what does unit mean?
In a strongly typed language you need to define what a function returns every time,
but sometimes a function does not return something.
This is what unit is used for, unit is used to defining when a function does not return anything.
let log = () => {
  print_endline("hello");
  print_endline("world")
};
log();
Functions always need argument
and with reason when you call the function “()” evaluates to “unit” and
since the last line in a function is automatically returned the function has also a return type of unit,
because print_endline returns “unit”.
So unit can be a bit confusing at the start coming from JavaScript
which is a weakly typed language,
but once you begin to use it more and understand the basic principals
like there always needs type even when nothing is given.

// ------------------------------------------------
Type option('a) for optional values

In many object-oriented languages, a variable having type string means that the variable can be either null or a string value. Types that include null are called nullable. Nullable types are problematic in that it’s easy to work with their values while forgetting to handle null. If – unexpectedly – a null appears, you get the infamous null pointer exceptions.

In ReasonML, types are never nullable. Instead, potentially missing values are handled via the following parameterized variant:

type option('a) =
  | None
  | Some('a);
option forces you to always consider the None case.

ReasonML’s support for option is minimal. The definition of this variant is part of the language, but the core standard library has no utility functions for working with optional values, yet. Until they are, you can use BuckleScript’s Js.Option.

// ------------------------------------------------
Type result('a) for error handling
result is another standard variant for error-handling in OCaml:
type result('good, 'bad) =
  | Ok('good)
  | Error('bad);
Until ReasonML’s core library supports it, you can use BuckleScript’s Js.Result.

// ------------------------------------------------
// epic type - не нашел информацию об этом типе !!!!

22.  История ReasonML Backlesript  и их взаимотношения.
https://www.imaginarycloud.com/blog/reasonml-react-as-first-intended/
Если бы ReasonML появился раньше  - реадкс бы не понадобился.
This made Facebook believe that it could be feasible and convenient
to move React itself closer to its roots. Eventuay,
they wouldn't have done so if they didn't have so much of the work already done...

Сравнительная таблица ReasonML и Elm


23. Everything is camel-cased in ReasonML

ReasonML is based on OCaml,
which uses snake-casing for lowercase names (create_resource)
and camel-casing for uppercase names (StringUtilities).
That’s why you’ll occasionally see snake-cased names.
But all new ReasonML code is camel-cased (StringUtilities, createResource).

Special prefixes and suffixes for variable names

A prefixed underscore means: don’t warn me about this variable not being used.

let f = (x, _y) => x;
  /* No warning about _y */
Suffixed apostrophes are legal (in math, x' means a modified version of x):

let x = 23;
let x' = x + 1;
Prefixed apostrophes are reserved for type variables (think generic types in C-style languages):

let len = (arr: array('a)) => Array.length(arr);
