1. Build a local version of OCaml compiler touch: s.h: Permission denied - Пришлось делать даунгрейд версии npm 4.0.0. - иначе не проходила установка

2. Два варианта создания стартового проекта:

	--- BuckleScript's bsb build system has an init command that generates a project template. The react theme offers a lightweight solution optimized for low learning overhead and ease of integration into an existing project.
It compiles to straightforward JS files, so you can open index.html directly from the file system. No server needed.


	--- Reason Scripts (Aka Create-React-App) As with create-react-app, reason-scripts comes with a server and hot-reloading built in.



3. Need to switch to nam 4.0.0 again - to install ocamlmerlin

3. Увидел много   <div> (ReasonReact.string(...) </div>  - многословность ReasonReact.string(

5. Размер js бандла reason React - 126 кБ. (  cra - 118 кБ)

4. Странный способ комментировать - не удобный
   Странный let в отличии от  "let in" в OCaml
   Кавычки - двойные (странно)?  - конкатенация строк  ++ - тоже многословно.
   Equal - deep Equal ?
   Integers - 32  Careful when you bind to JavaScript numbers! Long ones might be truncated. Bind JS number as float instead.

  Отличаются символы арифметических операций для целых  и плавающих чисел. "Why the heck can't I just use an overloaded + for both int and float?"

5.  Mutable Update.    Record fields can optionally be mutable. This allows you to update those fields in-place with the = operator.


6. Lists vs Arrays - Array
	let myList = [1, 2, 3];
	( in js it  [1,[2,[3]]]  - если очень много маленьких элементов в списке, то будет большой оверхед, в этом случае нужно испльзовать чистый массив  )


	Arrays are like lists, except they are:
		mutable
		fast at random access & updates
		fix-sized on native (flexibly sized on JavaScript)
		You'd surround them with [| and |].

		let myArray = [|"hello", "world", "how are you"|];

		--  Списки - очень удобная вещь для
		let a = [1,2,3];
		let b = [0, ...a];

		Will memory for the list a be actually allocated, or will doSomething simply reuse the list b?

		In the worst case, both a and b will exist in memory in their entirety.
		Note that even then, the contents of the two lists will only exist once,
		shared between both lists, so we're only talking about the "spine" of the lists existing twice.

		In the best case, depending on how b is defined and what doSomething does,
		the compiler might do some hoopy magic
		to turn the whole thing into a tight constant-space loop
		that generates the contents of the list as it processes them,
		possibly involving no memory allocation at all. Maybe.

		But even in the very worst case, you're duplicating the spine of the lists.
		You'll never duplicate the actual elements in the list.


7.  Функции - как в стрелочные функции  в Js.
	- есть возможность именнованных аргументов.
	In OCaml/Reason, you can attach labels to an argument:
	let addCoordinates = (~x, ~y) => {
  	/* use x and y here */
	};

  - rec - для рекурсивных функций

	- аноноимные функции
	   /* anonymous function. Listed for completeness only */
				(x) => (y) => 1;
				/* sugar for the above */
				(x, y) => 1;
				/* assign to a name */
				let add = (x, y) => 1;

				With Type Annotation:   let add = (x: int, y: int): int => 1;



Standalone Type Signature

And In Interface Files

8. let rec qsort = a =>
  switch (a) {
  | [] => []
  | [x, ...y] => {
    let p1 = qsort(List.filter(e => e > x, y));
    let p2 = qsort(List.filter(e => e <= x, y));
    p1 @ [x, ...p2]
    }
  };

let c = qsort([5,10,1,3,6,8,2]);
Js.log(c);

List.filter( - не удобно
@ - не удобно

В общем - на половину Ocaml, на половину JavaScript
больше в сторону Ocaml

Может лучще полностью прогрммировать на Ocaml ?


9.  Если компилируется, то значит работает.  Это правда.

10. ReasonML records -  это массивы JS.
Массивы - в 2.5 раза быстрее чем объекты (мои измерения)
Значит - рекогдс быстрее чем объекты.  Стейт - это в основном рекордс.
Таким образом работа со стейтом - очень быстрая.

11. Почему не TypeScript ? Я думаю - иммутаельность !

12.
“Most people make the mistake of thinking design is what it looks like.
People think it’s this veneer – that the designers are handed this box and told,
‘Make it look good!’
That’s not what we think design is.
It’s not just what it looks like and feels like.
Design is how it works.” – Steve Jobs

This quote is from the 2003 New York Times article “The Guts of a New Machine.”


13. Когда работаеш с рекордами - компилятор плодит много доп переменных
type person = {
  age: string,
  name: string,
  birthDate: string,
};
let me = {
  age: "5" ++ " " ++ string_of_int(Random.int(100)),
  name: "Big Reason" ++ " " ++ string_of_int(Random.int(100)),
  birthDate: "11.03.1980" ++ " " ++ string_of_int(Random.int(100)),
};
let notMe = {...me, name: "VVtu XA " ++ string_of_int(Random.int(10))};
Js.log(notMe);
-----------------
var me_000 = /* age */"5 " + String(Random.$$int(100));
var me_001 = /* name */"Big Reason " + String(Random.$$int(100));
var me_002 = /* birthDate */"11.03.1980 " + String(Random.$$int(100));
var me = /* record */[
  me_000,
  me_001,
  me_002
];

Чтобы можно было легко создавать новые рекорды из  старых

var notMe_000 = me_000;
var notMe_001 = /* name */"VVtu XA " + String(Random.$$int(10));
var notMe_002 = me_002;
var notMe = /* record */[
  notMe_000,
  notMe_001,
  notMe_002
];

13. Отличный каринг на примере перетасовки любых сущностей
 let reshuffle = dic =>
    dic
    |> List.map(item => (item, Random.int(10000000)))
    |> List.sort(((_, i), (_, j)) => i - j)
    |> List.map(((item, _)) => item);

		но нужны лишние скобки в последнем List.map

- !!! ошибка с недостающими скобками в треьей заключительной строке.
вот что значит "срестили ужа с ежом"
 (x,_) => x - означает функцию от двух переменных,
 а нам нужно было функцию с деструкцией тапла в аргументе
 в итоге правильно ((x,_)) => x  - это функция от одного аргумента.
Но все это сразу становится видным из за отличного фантастического контроля типов.

14. В общем - гораздо меньше хлама.

15. Первым делом подключил css и сделал инклюды
[%bs.raw {|require('./App.css')|}];  -- css взял из своего старого проекта без изменений

include Reshuffle;
include Dictionaries;   --  Вместе инклюдами подтянул типы данных



16. Вторым делом написал тип state
type state = {
  activeIndex: int,
  showEnglish: bool,
  showAdvanced: bool,
  appcodeIsSpeaking: bool,
  randomDictionary: Dictionaries.pairList,
};

тоже очень удобно для исключения дальнейших ошибок

17. Дальше написал
	initialState: () => {
    activeIndex: 0,
    showEnglish: false,
    showAdvanced: false,
    appcodeIsSpeaking: false,
    randomDictionary: Reshuffle.reshuffle(Dictionaries.dictionary1),
  },

18. Пропсы - как именованные аргументы
	let make = (~message, _children) => { }

	In OCaml/Reason, you can attach labels to an argument:
		let addCoordinates = (~x, ~y) => {
  		/* use x and y here */
		};
------

19. Решение задачи с яндекс собеседования бека
Найти за один проход по односвязанному списку 3 элемент с конца списка.
-- хвостовая рекурсия
let rec get3rec = (a, zapas, n) =>
  switch (a) {
  | [] =>
    if (n === 0) {
      switch (zapas) {
      | [] => (-1)
      | [o, ..._] => o
      };
    } else {
      (-1);
    }
  | [_, ...y] =>
    if (n === 0) {
      switch (zapas) {
      | [] => (-1)
      | [_, ...rest] => get3rec(y, rest, 0)
      };
    } else {
      get3rec(y, zapas, n - 1);
    }
  };

let get3 = a => get3rec(a, a, 3);

let otvet = get3([0,0,1,2,3,4,5,6,7,8]);

Js.log(otvet);